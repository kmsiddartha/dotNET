import { useContext, useEffect, useMemo } from 'react';
import { MultiChainStatesContext } from '../providers';
import { useEthers } from './useEthers';
/**
 * A low-level function that makes multiple calls to specific methods of specific contracts and returns values or error if present.
 * The hook will cause the component to refresh when values change.
 *
 * Calls will be combined into a single multicall across all uses of useChainCall, useChainCalls, useRawCall and useRawCalls.
 * It is recommended to use useCalls where applicable instead of this method.
 * @param calls List of calls, also see {@link ChainCall}. Calls need to be in the same order across component renders.
 * @returns
 */
export function useRawCalls(calls) {
    const { dispatchCalls, chains } = useContext(MultiChainStatesContext);
    const { chainId } = useEthers();
    useEffect(() => {
        const filteredCalls = calls.filter(Boolean);
        dispatchCalls({ type: 'ADD_CALLS', calls: filteredCalls });
        return () => dispatchCalls({ type: 'REMOVE_CALLS', calls: filteredCalls });
    }, [JSON.stringify(calls), dispatchCalls]);
    return useMemo(() => calls.map((call) => {
        return call ? extractCallResult(chains, call, chainId) : undefined;
    }), [JSON.stringify(calls), chains]);
}
/**
 * A low-level function that makes a call to a specific method of a specific contract and returns the value or error if present.
 * The hook will cause the component to refresh whenever a new block is mined and the value is changed.
 *
 * Calls will be combined into a single multicall across all uses of useChainCall, useChainCalls, useRawCall and useRawCalls.
 * It is recommended to use useCall where applicable instead of this method.
 *
 * @param call a single call, also see {@link RawCall}.
 *             A call can be Falsy, as it is important to keep the same ordering of hooks even if in a given render cycle
 *             and there might be not enough information to perform a call.
 * @returns result of multicall call.
 */
export function useRawCall(call) {
    return useRawCalls([call])[0];
}
function extractCallResult(chains, call, defaultChainId) {
    var _a, _b, _c, _d, _e;
    const chainId = (_a = call.chainId) !== null && _a !== void 0 ? _a : defaultChainId;
    return chainId !== undefined ? (_e = (_d = (_c = (_b = chains[chainId]) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.state) === null || _d === void 0 ? void 0 : _d[call.address]) === null || _e === void 0 ? void 0 : _e[call.data] : undefined;
}
//# sourceMappingURL=useRawCalls.js.map